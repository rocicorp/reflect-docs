import { Callout } from "nextra/components";
import { Steps } from "nextra/components";
import { Examples } from "../../components/icons/examples";

# Vercel Integration

You can deploy a new instance of your Reflect app for every push to `main` *and* every Vercel preview. This way previews can change mutators and data without conflicting with each other.

<Steps>

### Generate an API Key

```bash
npx reflect keys create my-vercel-api-key
```

For Permissions select `app:publish` and for Authorized Apps select `(created apps)`.

### Create Secret

In your Vercel project, go to Settings → Environment Variables.

Create a new environment variable named `REFLECT_AUTH_KEY` with the value of the key you generated above.

Create another environment variable named `REFLECT_APP_NAME` with the value of the name of your Reflect app.

### Create Custom Build

Add the following two files to the root of your repository:

```json filename="vercel.json"
{
  "buildCommand": "npm run build && node publish-reflect.js"
}
```

```js filename="publish-reflect.js"
const { spawn } = require("child_process");
const fs = require("fs");

// We're going to generate a unique Reflect app name for each preview like:
// <appname>-<refname>.
const appBaseName = getEnv(process.env.REFLECT_APP_NAME, "REFLECT_APP_NAME");
const refName = getEnv(
  process.env.VERCEL_GIT_COMMIT_REF,
  "VERCEL_GIT_COMMIT_REF"
);

// Reflect app names have limited allowed chars.
const appName = `${appBaseName}-${refName}`
  .toLowerCase()
  .replace(/^[^a-z]/, "")
  .replace(/[^a-z0-9-]/g, "-");

publish();

async function publish() {
  const output = await runCommand("npx", [
    "reflect",
    "publish",
    `--app=${appName}`,
    "--auth-key-from-env=REFLECT_AUTH_KEY",
  ]);

  // This is kind of a hack :)
  // We will provide an improved way to get the URL in the future.
  const lines = output.toString().split("\n");
  const success = lines.findIndex((line) =>
    line.includes("🎁 Published successfully to:")
  );
  const url = lines[success + 1];

  fs.writeFileSync("./.env", `NEXT_PUBLIC_REFLECT_SERVER=${url}`);
}

function runCommand(command, args) {
  console.log("running command: " + command + " " + args.join(" "));
  return new Promise((resolve, reject) => {
    const child = spawn(command, args);

    let output = "";
    child.stdout.on("data", (data) => {
      output += data;
      process.stdout.write(data);
    });

    child.stderr.on("data", (data) => {
      process.stderr.write(data);
    });

    child.on("close", (code) => {
      if (code !== 0) {
        reject(new Error(`Command failed with exit code ${code}`));
      } else {
        resolve(output);
      }
    });
  });
}

function getEnv(v, name) {
  if (!v) {
    throw new Error("Missing required env var: " + name);
  }
  return v;
}
```

<Callout>
**Note:** `publish-reflect.js` writes the environment variable `NEXT_PUBLIC_REFLECT_SERVER`. If you use a different framework than Next.js you will have to write the correct environment variable for that framework. For Examples, for Vite it would be `VITE_REFLECT_SERVER`.
</Callout>

### Use Generated Environment Variable

Update your app to use the `NEXT_PUBLIC_REFLECT_SERVER` environment variable, or whatever environment variable you chose:

```ts
const r = new Reflect<M>({
  server: process.env.NEXT_PUBLIC_REFLECT_SERVER!,
  // ...
});
```

</Steps>

## Examples

Most of our example apps run on Vercel and use continuous deployment. You can look at them for more examples of how to integrate:

- [Draw](https://github.com/rocicorp/reflect-draw/blob/main/publish-reflect.js) uses Next.js on Vercel.
- [Todo](https://github.com/rocicorp/reflect-todo/blob/main/publish-reflect.js) uses Vite/React on Vercel.
- [Loop](https://github.com/rocicorp/reflect-loop/blob/main/publish-reflect.js) is a more interesting Next.js/Vercel project that uses multiple Reflect apps which all have to be published together.
