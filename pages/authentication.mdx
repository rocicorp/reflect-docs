# Authentication

Reflect can control access to rooms by calling out to a separate server.

First, pass some auth token to the `Reflect` constructor's `auth` parameter. Typically this token will be generated by your server at page load time.

```ts filename="index.tsx"
const r = new Reflect({
  auth: "some-auth-token",
  // ...
});
```

Next, provide an `authHandler` in the server entrypoint that validates the auth token:

```ts filename="/reflect/index.ts"
import { mutators } from "../src/mutators";

export default function makeOptions() {
  return {
    authHandler: async (auth: string, roomID: string) {
      const response = await fetch(`/reflect-auth?auth=${auth}&roomID=${roomID}`);
      return (await response.json()) as AuthData;
    },
  };
}
```

If the user is allowed in the room, return an object matching `{userID: string}` from the `authHandler`. Otherwise, throw an error.

## Implementing `AuthHandler`

The most common implementation is to call an endpoint on your server, like in the example above.

But you can also use <a href="https://jwt.io/">JWTs</a> or similar. In that case, the `auth` string would be a JWT which would be verified in the `AuthHandler`:

```ts
async function jwtAuthHandler(auth: string, roomID: string): Promise<AuthData> {
  const decoded = await jwt.verify(auth, publicKey);
  return decoded as AuthData;
}
```

## Fine-Grained Authorization

Returning `{userID: string}` from the `AuthHandler` allows a user into a room.

It is also possible to control whether each individual mutation is allowed. To do so, return additional data as part of the `AuthData` object:

```ts
type MyAuthData = AuthData & { access: "read" | "write" };

async function detailedAuthHandler(
  auth: string,
  roomID: string,
): Promise<MyAuthData> {
  const response = await fetch(`/reflect-auth?auth=${auth}&roomID=${roomID}`);
  return (await response.json()) as MyAuthData;
}
```

This data will be visible to mutators via the `WriteTransaction.auth` property. You can use it to decide whether to allow a mutation:

```ts
const mutators = {
  editNodeContent: async (tx: WriteTransaction,
      {nodeID, content}: {nodeID: string, content: string}) {
    const node = await getNode(tx, nodeID);
    const auth = tx.auth as MyAuthData;
    if (auth === undefined || // auth is always undefined on client
        auth.access === 'write') {
      // Allow the mutation
    } else {
      console.error("Access denied");
    }
  }
}
```

Instead of simply skipping an unauthorized mutation, you can also perform different logic, for example making some similar change which is allowed.

Because Reflect is server-authoritative, whatever the server does will be synced to all clients, overriding any optimistic results. It's not possible for a client to "hack" their way into making a mutation that the server doesn't allow.
